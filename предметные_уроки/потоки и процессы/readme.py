
https://gb.ru/posts/multithread_pingpong?_ga=2.36702499.2040114921.1620183033-408663858.1620183033

Еще на заре эпохи компьютеров программисты поняли, что могут воспользоваться такой неиспользуемой вычислительной мощностью, выполняя одновременно несколько программ. Если распределить процессорное время среди множества задач, его мощность не будет тратиться впустую, пока некоторая конкретная задача ждет осуществления внешнего события. Такая технология обычно называется параллельной обработкой (или, иногда, «мультиобработкой» или даже «многозадачностью»), потому что возникает впечатление одновременного выполнения
нескольких заданий параллельно во времени.
Мы хотим, чтобы в единицу времени процессор успевал выполнить больше команд и  обработать больше данных. То есть нам надо уместить в каждом кванте времени больше выполненного кода. Представьте единицу выполнения кода в виде объекта  —  это и есть поток.
Разница между потоками и процессами
Потоки используют память, выделенную под процесс, а процессы требуют себе отдельное место в памяти. Поэтому потоки создаются и завершаются быстрее: системе не нужно каждый раз выделять им новое адресное пространство, а потом высвобождать его.

Процессы работают каждый со своими данными  —  обмениваться чем-то они могут только через механизм межпроцессного взаимодействия. Потоки обращаются к данным и ресурсам друг друга напрямую: что изменил один  —  сразу доступно всем. Поток может контролировать «собратьев» по процессу, в то время как процесс контролирует исключительно своих «дочек». Поэтому переключаться между потоками быстрее и коммуникация между ними организована проще.
Вот мы и подошли к главному. Многопоточность  —  это когда процесс приложения разбит на потоки, которые параллельно — в одну единицу времени — обрабатываются процессором.
Многопоточные приложения можно запускать и на одноядерных процессорах, но тогда  потоки выполняются по очереди: первый поработал, его состояние сохранили — дали поработать второму, сохранили — вернулись к первому или запустили третий, и т.д.
Производительность
Поскольку все потоки выполняются в пределах одного процесса, их
запуск не сопряжен с высокими накладными расходами, как при копировании процесса в целом. Издержки, связанные с копированием
порождаемых дочерних процессов и запуском потоков, могут быть
различными в зависимости от платформы, но обычно считается, что
потоки обходятся дешевле в смысле производительности.
Простота
Потоки выполнения заметно проще в обращении, особенно если
на сцену выходят более сложные аспекты процессов (например,
завершение процессов, обмен информацией между процессами
и процессы-«зомби», о которых рассказывается в главе 12).
Совместно используемая глобальная память
Кроме того, поскольку потоки выполняются в одном процессе, они
используют общую глобальную память процесса. Благодаря этому
потоки могут просто и естественно взаимодействовать друг с дру-


Для запуска новых, независимых потоков
выполнения в рамках одного и того же процесса в программах на языке
Python обычно используется либо низкоуровневый модуль _thread, позволяющий запускать функции в порожденных потоках выполнения,
либо высокоуровневый модуль threading, предоставляющий возмож-ность управления потоками выполнения с помощью объектов высокого
уровня, созданных на основе классов. Оба модуля также предусматривают инструменты синхронизации доступа к совместно используемым
объектам с помощью блокировок.